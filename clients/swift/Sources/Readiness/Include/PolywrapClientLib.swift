// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(PolywrapClientNative)
    import PolywrapClientNative
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_polywrap_native_4639_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_polywrap_native_4639_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
(_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
{
    try makeRustCall(callback, errorHandler: { try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol FFIBuilderConfigProtocol {
    func addEnv(uri: FfiUri, env: [UInt8])
    func removeEnv(uri: FfiUri)
    func addInterfaceImplementations(interfaceUri: FfiUri, implementationUris: [FfiUri])
    func addInterfaceImplementation(interfaceUri: FfiUri, implementationUri: FfiUri)
    func removeInterfaceImplementation(interfaceUri: FfiUri, implementationUri: FfiUri)
    func addWrapper(uri: FfiUri, wrapper: FfiWrapper)
    func removeWrapper(uri: FfiUri)
    func addPackage(uri: FfiUri, package: FfiWrapPackage)
    func removePackage(uri: FfiUri)
    func addRedirect(from: FfiUri, to: FfiUri)
    func removeRedirect(from: FfiUri)
    func addResolver(resolver: FfiUriResolver)
    func addSystemDefaults()
    func addWeb3Defaults()
    func build() -> FfiClient
}

public class FfiBuilderConfig: FFIBuilderConfigProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                polywrap_native_4639_FFIBuilderConfig_new($0)
            })
    }

    deinit {
        try! rustCall { ffi_polywrap_native_4639_FFIBuilderConfig_object_free(pointer, $0) }
    }

    public func addEnv(uri: FfiUri, env: [UInt8]) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_add_env(self.pointer,
                                                              FfiConverterTypeFfiUri.lower(uri),
                                                              FfiConverterSequenceUInt8.lower(env), $0)
            }
    }

    public func removeEnv(uri: FfiUri) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_remove_env(self.pointer,
                                                                 FfiConverterTypeFfiUri.lower(uri), $0)
            }
    }

    public func addInterfaceImplementations(interfaceUri: FfiUri, implementationUris: [FfiUri]) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_add_interface_implementations(self.pointer,
                                                                                    FfiConverterTypeFfiUri.lower(interfaceUri),
                                                                                    FfiConverterSequenceTypeFfiUri.lower(implementationUris), $0)
            }
    }

    public func addInterfaceImplementation(interfaceUri: FfiUri, implementationUri: FfiUri) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_add_interface_implementation(self.pointer,
                                                                                   FfiConverterTypeFfiUri.lower(interfaceUri),
                                                                                   FfiConverterTypeFfiUri.lower(implementationUri), $0)
            }
    }

    public func removeInterfaceImplementation(interfaceUri: FfiUri, implementationUri: FfiUri) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_remove_interface_implementation(self.pointer,
                                                                                      FfiConverterTypeFfiUri.lower(interfaceUri),
                                                                                      FfiConverterTypeFfiUri.lower(implementationUri), $0)
            }
    }

    public func addWrapper(uri: FfiUri, wrapper: FfiWrapper) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_add_wrapper(self.pointer,
                                                                  FfiConverterTypeFfiUri.lower(uri),
                                                                  FfiConverterCallbackInterfaceFfiWrapper.lower(wrapper), $0)
            }
    }

    public func removeWrapper(uri: FfiUri) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_remove_wrapper(self.pointer,
                                                                     FfiConverterTypeFfiUri.lower(uri), $0)
            }
    }

    public func addPackage(uri: FfiUri, package: FfiWrapPackage) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_add_package(self.pointer,
                                                                  FfiConverterTypeFfiUri.lower(uri),
                                                                  FfiConverterCallbackInterfaceFfiWrapPackage.lower(package), $0)
            }
    }

    public func removePackage(uri: FfiUri) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_remove_package(self.pointer,
                                                                     FfiConverterTypeFfiUri.lower(uri), $0)
            }
    }

    public func addRedirect(from: FfiUri, to: FfiUri) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_add_redirect(self.pointer,
                                                                   FfiConverterTypeFfiUri.lower(from),
                                                                   FfiConverterTypeFfiUri.lower(to), $0)
            }
    }

    public func removeRedirect(from: FfiUri) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_remove_redirect(self.pointer,
                                                                      FfiConverterTypeFfiUri.lower(from), $0)
            }
    }

    public func addResolver(resolver: FfiUriResolver) {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_add_resolver(self.pointer,
                                                                   FfiConverterCallbackInterfaceFfiUriResolver.lower(resolver), $0)
            }
    }

    public func addSystemDefaults() {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_add_system_defaults(self.pointer, $0)
            }
    }

    public func addWeb3Defaults() {
        try!
            rustCall {
                polywrap_native_4639_FFIBuilderConfig_add_web3_defaults(self.pointer, $0)
            }
    }

    public func build() -> FfiClient {
        return try! FfiConverterTypeFfiClient.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIBuilderConfig_build(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeFfiBuilderConfig: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiBuilderConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiBuilderConfig {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiBuilderConfig, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiBuilderConfig {
        return FfiBuilderConfig(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiBuilderConfig) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol FFIClientProtocol {
    func invokeRaw(uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8]
    func getImplementations(uri: FfiUri) throws -> [FfiUri]
    func getInterfaces() -> [String: [FfiUri]]?
    func getEnvByUri(uri: FfiUri) -> [UInt8]?
    func asInvoker() -> FfiInvoker
    func invokeWrapperRaw(wrapper: FfiWrapper, uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8]
    func loadWrapper(uri: FfiUri, resolutionContext: FfiUriResolutionContext?) throws -> FfiWrapper
}

public class FfiClient: FFIClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_polywrap_native_4639_FFIClient_object_free(pointer, $0) }
    }

    public func invokeRaw(uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeFfiError.self) {
                polywrap_native_4639_FFIClient_invoke_raw(self.pointer,
                                                          FfiConverterTypeFfiUri.lower(uri),
                                                          FfiConverterString.lower(method),
                                                          FfiConverterOptionSequenceUInt8.lower(args),
                                                          FfiConverterOptionSequenceUInt8.lower(env),
                                                          FfiConverterOptionTypeFfiUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }

    public func getImplementations(uri: FfiUri) throws -> [FfiUri] {
        return try FfiConverterSequenceTypeFfiUri.lift(
            rustCallWithError(FfiConverterTypeFfiError.self) {
                polywrap_native_4639_FFIClient_get_implementations(self.pointer,
                                                                   FfiConverterTypeFfiUri.lower(uri), $0)
            }
        )
    }

    public func getInterfaces() -> [String: [FfiUri]]? {
        return try! FfiConverterOptionDictionaryStringSequenceTypeFfiUri.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIClient_get_interfaces(self.pointer, $0)
                }
        )
    }

    public func getEnvByUri(uri: FfiUri) -> [UInt8]? {
        return try! FfiConverterOptionSequenceUInt8.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIClient_get_env_by_uri(self.pointer,
                                                                  FfiConverterTypeFfiUri.lower(uri), $0)
                }
        )
    }

    public func asInvoker() -> FfiInvoker {
        return try! FfiConverterTypeFfiInvoker.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIClient_as_invoker(self.pointer, $0)
                }
        )
    }

    public func invokeWrapperRaw(wrapper: FfiWrapper, uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeFfiError.self) {
                polywrap_native_4639_FFIClient_invoke_wrapper_raw(self.pointer,
                                                                  FfiConverterCallbackInterfaceFfiWrapper.lower(wrapper),
                                                                  FfiConverterTypeFfiUri.lower(uri),
                                                                  FfiConverterString.lower(method),
                                                                  FfiConverterOptionSequenceUInt8.lower(args),
                                                                  FfiConverterOptionSequenceUInt8.lower(env),
                                                                  FfiConverterOptionTypeFfiUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }

    public func loadWrapper(uri: FfiUri, resolutionContext: FfiUriResolutionContext?) throws -> FfiWrapper {
        return try FfiConverterCallbackInterfaceFfiWrapper.lift(
            rustCallWithError(FfiConverterTypeFfiError.self) {
                polywrap_native_4639_FFIClient_load_wrapper(self.pointer,
                                                            FfiConverterTypeFfiUri.lower(uri),
                                                            FfiConverterOptionTypeFfiUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }
}

public struct FfiConverterTypeFfiClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiClient

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiClient {
        return FfiClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiClient) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol FFIInvokerProtocol {
    func invokeRaw(uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8]
    func getImplementations(uri: FfiUri) throws -> [FfiUri]
    func getInterfaces() -> [String: [FfiUri]]?
    func getEnvByUri(uri: FfiUri) -> [UInt8]?
}

public class FfiInvoker: FFIInvokerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_polywrap_native_4639_FFIInvoker_object_free(pointer, $0) }
    }

    public func invokeRaw(uri: FfiUri, method: String, args: [UInt8]?, env: [UInt8]?, resolutionContext: FfiUriResolutionContext?) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeFfiError.self) {
                polywrap_native_4639_FFIInvoker_invoke_raw(self.pointer,
                                                           FfiConverterTypeFfiUri.lower(uri),
                                                           FfiConverterString.lower(method),
                                                           FfiConverterOptionSequenceUInt8.lower(args),
                                                           FfiConverterOptionSequenceUInt8.lower(env),
                                                           FfiConverterOptionTypeFfiUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }

    public func getImplementations(uri: FfiUri) throws -> [FfiUri] {
        return try FfiConverterSequenceTypeFfiUri.lift(
            rustCallWithError(FfiConverterTypeFfiError.self) {
                polywrap_native_4639_FFIInvoker_get_implementations(self.pointer,
                                                                    FfiConverterTypeFfiUri.lower(uri), $0)
            }
        )
    }

    public func getInterfaces() -> [String: [FfiUri]]? {
        return try! FfiConverterOptionDictionaryStringSequenceTypeFfiUri.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIInvoker_get_interfaces(self.pointer, $0)
                }
        )
    }

    public func getEnvByUri(uri: FfiUri) -> [UInt8]? {
        return try! FfiConverterOptionSequenceUInt8.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIInvoker_get_env_by_uri(self.pointer,
                                                                   FfiConverterTypeFfiUri.lower(uri), $0)
                }
        )
    }
}

public struct FfiConverterTypeFfiInvoker: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiInvoker

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiInvoker {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiInvoker, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiInvoker {
        return FfiInvoker(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiInvoker) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol FFIRecursiveUriResolverProtocol {
    func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper
}

public class FfiRecursiveUriResolver: FFIRecursiveUriResolverProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(uriResolver: FfiUriResolver) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                polywrap_native_4639_FFIRecursiveUriResolver_new(
                    FfiConverterCallbackInterfaceFfiUriResolver.lower(uriResolver), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_polywrap_native_4639_FFIRecursiveUriResolver_object_free(pointer, $0) }
    }

    public func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper {
        return try FfiConverterCallbackInterfaceFfiUriPackageOrWrapper.lift(
            rustCallWithError(FfiConverterTypeFfiError.self) {
                polywrap_native_4639_FFIRecursiveUriResolver_try_resolve_uri(self.pointer,
                                                                             FfiConverterTypeFfiUri.lower(uri),
                                                                             FfiConverterTypeFfiInvoker.lower(invoker),
                                                                             FfiConverterTypeFfiUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }
}

public struct FfiConverterTypeFfiRecursiveUriResolver: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiRecursiveUriResolver

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiRecursiveUriResolver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiRecursiveUriResolver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiRecursiveUriResolver {
        return FfiRecursiveUriResolver(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiRecursiveUriResolver) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol FFIStaticUriResolverProtocol {
    func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper
}

public class FfiStaticUriResolver: FFIStaticUriResolverProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(uriMap: [String: FfiUriPackageOrWrapper]) throws {
        try self.init(unsafeFromRawPointer:

            rustCallWithError(FfiConverterTypeFfiError.self) {
                polywrap_native_4639_FFIStaticUriResolver_new(
                    FfiConverterDictionaryStringCallbackInterfaceFfiUriPackageOrWrapper.lower(uriMap), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_polywrap_native_4639_FFIStaticUriResolver_object_free(pointer, $0) }
    }

    public func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper {
        return try FfiConverterCallbackInterfaceFfiUriPackageOrWrapper.lift(
            rustCallWithError(FfiConverterTypeFfiError.self) {
                polywrap_native_4639_FFIStaticUriResolver_try_resolve_uri(self.pointer,
                                                                          FfiConverterTypeFfiUri.lower(uri),
                                                                          FfiConverterTypeFfiInvoker.lower(invoker),
                                                                          FfiConverterTypeFfiUriResolutionContext.lower(resolutionContext), $0)
            }
        )
    }
}

public struct FfiConverterTypeFfiStaticUriResolver: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiStaticUriResolver

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiStaticUriResolver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiStaticUriResolver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStaticUriResolver {
        return FfiStaticUriResolver(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiStaticUriResolver) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol FFIUriProtocol {
    func authority() -> String
    func path() -> String
    func toStringUri() -> String
}

public class FfiUri: FFIUriProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(authority: String, path: String, uri: String) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                polywrap_native_4639_FFIUri_new(
                    FfiConverterString.lower(authority),
                    FfiConverterString.lower(path),
                    FfiConverterString.lower(uri), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_polywrap_native_4639_FFIUri_object_free(pointer, $0) }
    }

    public func authority() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIUri_authority(self.pointer, $0)
                }
        )
    }

    public func path() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIUri_path(self.pointer, $0)
                }
        )
    }

    public func toStringUri() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIUri_to_string_uri(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeFfiUri: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiUri

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUri {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiUri, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUri {
        return FfiUri(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiUri) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol FFIUriResolutionContextProtocol {
    func setResolutionPath(resolutionPath: [String])
    func setHistory(history: [FfiUriResolutionStep])
    func setResolvingUriMap(resolvingUriMap: [String: Bool])
    func setStartResolving(uri: FfiUri)
    func setStopResolving(uri: FfiUri)
    func trackStep(step: FfiUriResolutionStep)
    func getHistory() -> [FfiUriResolutionStep]
    func getResolutionPath() -> [FfiUri]
    func createSubHistoryContext() -> FfiUriResolutionContext
    func createSubContext() -> FfiUriResolutionContext
}

public class FfiUriResolutionContext: FFIUriResolutionContextProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                polywrap_native_4639_FFIUriResolutionContext_new($0)
            })
    }

    deinit {
        try! rustCall { ffi_polywrap_native_4639_FFIUriResolutionContext_object_free(pointer, $0) }
    }

    public func setResolutionPath(resolutionPath: [String]) {
        try!
            rustCall {
                polywrap_native_4639_FFIUriResolutionContext_set_resolution_path(self.pointer,
                                                                                 FfiConverterSequenceString.lower(resolutionPath), $0)
            }
    }

    public func setHistory(history: [FfiUriResolutionStep]) {
        try!
            rustCall {
                polywrap_native_4639_FFIUriResolutionContext_set_history(self.pointer,
                                                                         FfiConverterSequenceTypeFfiUriResolutionStep.lower(history), $0)
            }
    }

    public func setResolvingUriMap(resolvingUriMap: [String: Bool]) {
        try!
            rustCall {
                polywrap_native_4639_FFIUriResolutionContext_set_resolving_uri_map(self.pointer,
                                                                                   FfiConverterDictionaryStringBool.lower(resolvingUriMap), $0)
            }
    }

    public func setStartResolving(uri: FfiUri) {
        try!
            rustCall {
                polywrap_native_4639_FFIUriResolutionContext_set_start_resolving(self.pointer,
                                                                                 FfiConverterTypeFfiUri.lower(uri), $0)
            }
    }

    public func setStopResolving(uri: FfiUri) {
        try!
            rustCall {
                polywrap_native_4639_FFIUriResolutionContext_set_stop_resolving(self.pointer,
                                                                                FfiConverterTypeFfiUri.lower(uri), $0)
            }
    }

    public func trackStep(step: FfiUriResolutionStep) {
        try!
            rustCall {
                polywrap_native_4639_FFIUriResolutionContext_track_step(self.pointer,
                                                                        FfiConverterTypeFfiUriResolutionStep.lower(step), $0)
            }
    }

    public func getHistory() -> [FfiUriResolutionStep] {
        return try! FfiConverterSequenceTypeFfiUriResolutionStep.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIUriResolutionContext_get_history(self.pointer, $0)
                }
        )
    }

    public func getResolutionPath() -> [FfiUri] {
        return try! FfiConverterSequenceTypeFfiUri.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIUriResolutionContext_get_resolution_path(self.pointer, $0)
                }
        )
    }

    public func createSubHistoryContext() -> FfiUriResolutionContext {
        return try! FfiConverterTypeFfiUriResolutionContext.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIUriResolutionContext_create_sub_history_context(self.pointer, $0)
                }
        )
    }

    public func createSubContext() -> FfiUriResolutionContext {
        return try! FfiConverterTypeFfiUriResolutionContext.lift(
            try!
                rustCall {
                    polywrap_native_4639_FFIUriResolutionContext_create_sub_context(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeFfiUriResolutionContext: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiUriResolutionContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUriResolutionContext {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiUriResolutionContext, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUriResolutionContext {
        return FfiUriResolutionContext(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiUriResolutionContext) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public protocol FFIWasmWrapperProtocol {
    func invoke(method: String, args: [UInt8]?, env: [UInt8]?, invoker: FfiInvoker) throws -> [UInt8]
}

public class FfiWasmWrapper: FFIWasmWrapperProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(wasmModule: [UInt8]) {
        self.init(unsafeFromRawPointer: try!

            rustCall {
                polywrap_native_4639_FFIWasmWrapper_new(
                    FfiConverterSequenceUInt8.lower(wasmModule), $0
                )
            })
    }

    deinit {
        try! rustCall { ffi_polywrap_native_4639_FFIWasmWrapper_object_free(pointer, $0) }
    }

    public func invoke(method: String, args: [UInt8]?, env: [UInt8]?, invoker: FfiInvoker) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeFfiError.self) {
                polywrap_native_4639_FFIWasmWrapper_invoke(self.pointer,
                                                           FfiConverterString.lower(method),
                                                           FfiConverterOptionSequenceUInt8.lower(args),
                                                           FfiConverterOptionSequenceUInt8.lower(env),
                                                           FfiConverterTypeFfiInvoker.lower(invoker), $0)
            }
        )
    }
}

public struct FfiConverterTypeFfiWasmWrapper: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiWasmWrapper

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiWasmWrapper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiWasmWrapper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiWasmWrapper {
        return FfiWasmWrapper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiWasmWrapper) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public struct FfiUriResolutionStep {
    public var sourceUri: FfiUri
    public var result: FfiUriPackageOrWrapper
    public var description: String?
    public var subHistory: [FfiUriResolutionStep]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sourceUri: FfiUri, result: FfiUriPackageOrWrapper, description: String?, subHistory: [FfiUriResolutionStep]?) {
        self.sourceUri = sourceUri
        self.result = result
        self.description = description
        self.subHistory = subHistory
    }
}

public struct FfiConverterTypeFfiUriResolutionStep: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUriResolutionStep {
        return try FfiUriResolutionStep(
            sourceUri: FfiConverterTypeFfiUri.read(from: &buf),
            result: FfiConverterCallbackInterfaceFfiUriPackageOrWrapper.read(from: &buf),
            description: FfiConverterOptionString.read(from: &buf),
            subHistory: FfiConverterOptionSequenceTypeFfiUriResolutionStep.read(from: &buf)
        )
    }

    public static func write(_ value: FfiUriResolutionStep, into buf: inout [UInt8]) {
        FfiConverterTypeFfiUri.write(value.sourceUri, into: &buf)
        FfiConverterCallbackInterfaceFfiUriPackageOrWrapper.write(value.result, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionSequenceTypeFfiUriResolutionStep.write(value.subHistory, into: &buf)
    }
}

public func FfiConverterTypeFfiUriResolutionStep_lift(_ buf: RustBuffer) throws -> FfiUriResolutionStep {
    return try FfiConverterTypeFfiUriResolutionStep.lift(buf)
}

public func FfiConverterTypeFfiUriResolutionStep_lower(_ value: FfiUriResolutionStep) -> RustBuffer {
    return FfiConverterTypeFfiUriResolutionStep.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FfiUriPackageOrWrapperKind {
    case uri
    case package
    case wrapper
}

public struct FfiConverterTypeFfiUriPackageOrWrapperKind: FfiConverterRustBuffer {
    typealias SwiftType = FfiUriPackageOrWrapperKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUriPackageOrWrapperKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .uri

        case 2: return .package

        case 3: return .wrapper

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiUriPackageOrWrapperKind, into buf: inout [UInt8]) {
        switch value {
        case .uri:
            writeInt(&buf, Int32(1))

        case .package:
            writeInt(&buf, Int32(2))

        case .wrapper:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeFfiUriPackageOrWrapperKind_lift(_ buf: RustBuffer) throws -> FfiUriPackageOrWrapperKind {
    return try FfiConverterTypeFfiUriPackageOrWrapperKind.lift(buf)
}

public func FfiConverterTypeFfiUriPackageOrWrapperKind_lower(_ value: FfiUriPackageOrWrapperKind) -> RustBuffer {
    return FfiConverterTypeFfiUriPackageOrWrapperKind.lower(value)
}

extension FfiUriPackageOrWrapperKind: Equatable, Hashable {}

public enum FfiError {
    case UriParseError(err: String)
    case RedirectsError(err: String, resolutionStack: [String: String])
    case WrapperError(err: String)
    case WrapperCreateError(err: String)
    case InvokeError(uri: String, method: String, err: String)
    case LoadWrapperError(uri: String, err: String)
    case WasmWrapperError(err: String)
    case ResolutionError(err: String)
    case UriNotFoundError(uri: String)
    case MsgpackError(err: String)
    case ManifestError(err: String)
    case FileReadError(err: String)
    case ResolverError(err: String)
    case PluginError(err: String)
    case RuntimeError(err: String)
    case OtherError(err: String)
}

public struct FfiConverterTypeFfiError: FfiConverterRustBuffer {
    typealias SwiftType = FfiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .UriParseError(
                err: FfiConverterString.read(from: &buf)
            )
        case 2: return try .RedirectsError(
                err: FfiConverterString.read(from: &buf),
                resolutionStack: FfiConverterDictionaryStringString.read(from: &buf)
            )
        case 3: return try .WrapperError(
                err: FfiConverterString.read(from: &buf)
            )
        case 4: return try .WrapperCreateError(
                err: FfiConverterString.read(from: &buf)
            )
        case 5: return try .InvokeError(
                uri: FfiConverterString.read(from: &buf),
                method: FfiConverterString.read(from: &buf),
                err: FfiConverterString.read(from: &buf)
            )
        case 6: return try .LoadWrapperError(
                uri: FfiConverterString.read(from: &buf),
                err: FfiConverterString.read(from: &buf)
            )
        case 7: return try .WasmWrapperError(
                err: FfiConverterString.read(from: &buf)
            )
        case 8: return try .ResolutionError(
                err: FfiConverterString.read(from: &buf)
            )
        case 9: return try .UriNotFoundError(
                uri: FfiConverterString.read(from: &buf)
            )
        case 10: return try .MsgpackError(
                err: FfiConverterString.read(from: &buf)
            )
        case 11: return try .ManifestError(
                err: FfiConverterString.read(from: &buf)
            )
        case 12: return try .FileReadError(
                err: FfiConverterString.read(from: &buf)
            )
        case 13: return try .ResolverError(
                err: FfiConverterString.read(from: &buf)
            )
        case 14: return try .PluginError(
                err: FfiConverterString.read(from: &buf)
            )
        case 15: return try .RuntimeError(
                err: FfiConverterString.read(from: &buf)
            )
        case 16: return try .OtherError(
                err: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiError, into buf: inout [UInt8]) {
        switch value {
        case let .UriParseError(err):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(err, into: &buf)

        case let .RedirectsError(err, resolutionStack):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(err, into: &buf)
            FfiConverterDictionaryStringString.write(resolutionStack, into: &buf)

        case let .WrapperError(err):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(err, into: &buf)

        case let .WrapperCreateError(err):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(err, into: &buf)

        case let .InvokeError(uri, method, err):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(uri, into: &buf)
            FfiConverterString.write(method, into: &buf)
            FfiConverterString.write(err, into: &buf)

        case let .LoadWrapperError(uri, err):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(uri, into: &buf)
            FfiConverterString.write(err, into: &buf)

        case let .WasmWrapperError(err):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(err, into: &buf)

        case let .ResolutionError(err):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(err, into: &buf)

        case let .UriNotFoundError(uri):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(uri, into: &buf)

        case let .MsgpackError(err):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(err, into: &buf)

        case let .ManifestError(err):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(err, into: &buf)

        case let .FileReadError(err):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(err, into: &buf)

        case let .ResolverError(err):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(err, into: &buf)

        case let .PluginError(err):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(err, into: &buf)

        case let .RuntimeError(err):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(err, into: &buf)

        case let .OtherError(err):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(err, into: &buf)
        }
    }
}

extension FfiError: Equatable, Hashable {}

extension FfiError: Error {}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private typealias UniFFICallbackHandle = UInt64
private class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

// Declaration and FfiConverters for FfiUriPackageOrWrapper Callback Interface

public protocol FfiUriPackageOrWrapper: AnyObject {
    func getKind() -> FfiUriPackageOrWrapperKind
    func asUri() -> FfiUri
    func asWrapper() -> FfiUriWrapper
    func asPackage() -> FfiUriWrapPackage
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceFfiUriPackageOrWrapper: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeGetKind(_ swiftCallbackInterface: FfiUriPackageOrWrapper, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            let result = swiftCallbackInterface.getKind()
            var writer = [UInt8]()
            FfiConverterTypeFfiUriPackageOrWrapperKind.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }
        func invokeAsUri(_ swiftCallbackInterface: FfiUriPackageOrWrapper, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            let result = swiftCallbackInterface.asUri()
            var writer = [UInt8]()
            FfiConverterTypeFfiUri.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }
        func invokeAsWrapper(_ swiftCallbackInterface: FfiUriPackageOrWrapper, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            let result = swiftCallbackInterface.asWrapper()
            var writer = [UInt8]()
            FfiConverterCallbackInterfaceFfiUriWrapper.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }
        func invokeAsPackage(_ swiftCallbackInterface: FfiUriPackageOrWrapper, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            let result = swiftCallbackInterface.asPackage()
            var writer = [UInt8]()
            FfiConverterCallbackInterfaceFfiUriWrapPackage.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }

        let cb: FfiUriPackageOrWrapper
        do {
            cb = try FfiConverterCallbackInterfaceFfiUriPackageOrWrapper.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FFIUriPackageOrWrapper: Invalid handle")
            return -1
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceFfiUriPackageOrWrapper.drop(handle: handle)
            // No return value.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 0
        case 1:
            do {
                out_buf.pointee = try invokeGetKind(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }
        case 2:
            do {
                out_buf.pointee = try invokeAsUri(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }
        case 3:
            do {
                out_buf.pointee = try invokeAsWrapper(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }
        case 4:
            do {
                out_buf.pointee = try invokeAsPackage(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return -1
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiUriPackageOrWrapper {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_polywrap_native_4639_FFIUriPackageOrWrapper_init_callback(foreignCallbackCallbackInterfaceFfiUriPackageOrWrapper, err)
        }
    }

    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<FfiUriPackageOrWrapper>()
}

extension FfiConverterCallbackInterfaceFfiUriPackageOrWrapper: FfiConverter {
    typealias SwiftType = FfiUriPackageOrWrapper
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for FfiUriResolver Callback Interface

public protocol FfiUriResolver: AnyObject {
    func tryResolveUri(uri: FfiUri, invoker: FfiInvoker, resolutionContext: FfiUriResolutionContext) throws -> FfiUriPackageOrWrapper
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceFfiUriResolver: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeTryResolveUri(_ swiftCallbackInterface: FfiUriResolver, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            let result = try swiftCallbackInterface.tryResolveUri(
                uri: FfiConverterTypeFfiUri.read(from: &reader),
                invoker: FfiConverterTypeFfiInvoker.read(from: &reader),
                resolutionContext: FfiConverterTypeFfiUriResolutionContext.read(from: &reader)
            )
            var writer = [UInt8]()
            FfiConverterCallbackInterfaceFfiUriPackageOrWrapper.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }

        let cb: FfiUriResolver
        do {
            cb = try FfiConverterCallbackInterfaceFfiUriResolver.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FFIUriResolver: Invalid handle")
            return -1
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceFfiUriResolver.drop(handle: handle)
            // No return value.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 0
        case 1:
            do {
                out_buf.pointee = try invokeTryResolveUri(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch let error as FfiError {
                out_buf.pointee = FfiConverterTypeFfiError.lower(error)
                return -2
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return -1
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiUriResolver {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_polywrap_native_4639_FFIUriResolver_init_callback(foreignCallbackCallbackInterfaceFfiUriResolver, err)
        }
    }

    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<FfiUriResolver>()
}

extension FfiConverterCallbackInterfaceFfiUriResolver: FfiConverter {
    typealias SwiftType = FfiUriResolver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for FfiUriWrapPackage Callback Interface

public protocol FfiUriWrapPackage: AnyObject {
    func getUri() -> FfiUri
    func getPackage() -> FfiWrapPackage
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceFfiUriWrapPackage: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeGetUri(_ swiftCallbackInterface: FfiUriWrapPackage, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            let result = swiftCallbackInterface.getUri()
            var writer = [UInt8]()
            FfiConverterTypeFfiUri.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }
        func invokeGetPackage(_ swiftCallbackInterface: FfiUriWrapPackage, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            let result = swiftCallbackInterface.getPackage()
            var writer = [UInt8]()
            FfiConverterCallbackInterfaceFfiWrapPackage.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }

        let cb: FfiUriWrapPackage
        do {
            cb = try FfiConverterCallbackInterfaceFfiUriWrapPackage.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FFIUriWrapPackage: Invalid handle")
            return -1
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceFfiUriWrapPackage.drop(handle: handle)
            // No return value.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 0
        case 1:
            do {
                out_buf.pointee = try invokeGetUri(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }
        case 2:
            do {
                out_buf.pointee = try invokeGetPackage(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return -1
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiUriWrapPackage {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_polywrap_native_4639_FFIUriWrapPackage_init_callback(foreignCallbackCallbackInterfaceFfiUriWrapPackage, err)
        }
    }

    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<FfiUriWrapPackage>()
}

extension FfiConverterCallbackInterfaceFfiUriWrapPackage: FfiConverter {
    typealias SwiftType = FfiUriWrapPackage
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for FfiUriWrapper Callback Interface

public protocol FfiUriWrapper: AnyObject {
    func getUri() -> FfiUri
    func getWrapper() -> FfiWrapper
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceFfiUriWrapper: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeGetUri(_ swiftCallbackInterface: FfiUriWrapper, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            let result = swiftCallbackInterface.getUri()
            var writer = [UInt8]()
            FfiConverterTypeFfiUri.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }
        func invokeGetWrapper(_ swiftCallbackInterface: FfiUriWrapper, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            let result = swiftCallbackInterface.getWrapper()
            var writer = [UInt8]()
            FfiConverterCallbackInterfaceFfiWrapper.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }

        let cb: FfiUriWrapper
        do {
            cb = try FfiConverterCallbackInterfaceFfiUriWrapper.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FFIUriWrapper: Invalid handle")
            return -1
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceFfiUriWrapper.drop(handle: handle)
            // No return value.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 0
        case 1:
            do {
                out_buf.pointee = try invokeGetUri(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }
        case 2:
            do {
                out_buf.pointee = try invokeGetWrapper(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return -1
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiUriWrapper {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_polywrap_native_4639_FFIUriWrapper_init_callback(foreignCallbackCallbackInterfaceFfiUriWrapper, err)
        }
    }

    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<FfiUriWrapper>()
}

extension FfiConverterCallbackInterfaceFfiUriWrapper: FfiConverter {
    typealias SwiftType = FfiUriWrapper
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for FfiWrapPackage Callback Interface

public protocol FfiWrapPackage: AnyObject {
    func createWrapper() throws -> FfiWrapper
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceFfiWrapPackage: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeCreateWrapper(_ swiftCallbackInterface: FfiWrapPackage, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }
            let result = try swiftCallbackInterface.createWrapper()
            var writer = [UInt8]()
            FfiConverterCallbackInterfaceFfiWrapper.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }

        let cb: FfiWrapPackage
        do {
            cb = try FfiConverterCallbackInterfaceFfiWrapPackage.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FFIWrapPackage: Invalid handle")
            return -1
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceFfiWrapPackage.drop(handle: handle)
            // No return value.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 0
        case 1:
            do {
                out_buf.pointee = try invokeCreateWrapper(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch let error as FfiError {
                out_buf.pointee = FfiConverterTypeFfiError.lower(error)
                return -2
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return -1
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiWrapPackage {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_polywrap_native_4639_FFIWrapPackage_init_callback(foreignCallbackCallbackInterfaceFfiWrapPackage, err)
        }
    }

    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<FfiWrapPackage>()
}

extension FfiConverterCallbackInterfaceFfiWrapPackage: FfiConverter {
    typealias SwiftType = FfiWrapPackage
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for FfiWrapper Callback Interface

public protocol FfiWrapper: AnyObject {
    func invoke(method: String, args: [UInt8]?, env: [UInt8]?, invoker: FfiInvoker) throws -> [UInt8]
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceFfiWrapper: ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeInvoke(_ swiftCallbackInterface: FfiWrapper, _ args: RustBuffer) throws -> RustBuffer {
            defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            let result = try swiftCallbackInterface.invoke(
                method: FfiConverterString.read(from: &reader),
                args: FfiConverterOptionSequenceUInt8.read(from: &reader),
                env: FfiConverterOptionSequenceUInt8.read(from: &reader),
                invoker: FfiConverterTypeFfiInvoker.read(from: &reader)
            )
            var writer = [UInt8]()
            FfiConverterSequenceUInt8.write(result, into: &writer)
            return RustBuffer(bytes: writer) // TODO: catch errors and report them back to Rust.
            // https://github.com/mozilla/uniffi-rs/issues/351
        }

        let cb: FfiWrapper
        do {
            cb = try FfiConverterCallbackInterfaceFfiWrapper.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FFIWrapper: Invalid handle")
            return -1
        }

        switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceFfiWrapper.drop(handle: handle)
            // No return value.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return 0
        case 1:
            do {
                out_buf.pointee = try invokeInvoke(cb, args)
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            } catch let error as FfiError {
                out_buf.pointee = FfiConverterTypeFfiError.lower(error)
                return -2
            } catch {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return -1
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
            return -1
        }
    }

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiWrapper {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_polywrap_native_4639_FFIWrapper_init_callback(foreignCallbackCallbackInterfaceFfiWrapper, err)
        }
    }

    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<FfiWrapper>()
}

extension FfiConverterCallbackInterfaceFfiWrapper: FfiConverter {
    typealias SwiftType = FfiWrapper
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFfiUriResolutionContext: FfiConverterRustBuffer {
    typealias SwiftType = FfiUriResolutionContext?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiUriResolutionContext.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiUriResolutionContext.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeFfiUriResolutionStep: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUriResolutionStep]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFfiUriResolutionStep.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFfiUriResolutionStep.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionDictionaryStringSequenceTypeFfiUri: FfiConverterRustBuffer {
    typealias SwiftType = [String: [FfiUri]]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringSequenceTypeFfiUri.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringSequenceTypeFfiUri.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiUri: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUri]

    public static func write(_ value: [FfiUri], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiUri.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiUri] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiUri]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiUri.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiUriResolutionStep: FfiConverterRustBuffer {
    typealias SwiftType = [FfiUriResolutionStep]

    public static func write(_ value: [FfiUriResolutionStep], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiUriResolutionStep.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiUriResolutionStep] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiUriResolutionStep]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiUriResolutionStep.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringCallbackInterfaceFfiUriPackageOrWrapper: FfiConverterRustBuffer {
    public static func write(_ value: [String: FfiUriPackageOrWrapper], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterCallbackInterfaceFfiUriPackageOrWrapper.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: FfiUriPackageOrWrapper] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: FfiUriPackageOrWrapper]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterCallbackInterfaceFfiUriPackageOrWrapper.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringSequenceTypeFfiUri: FfiConverterRustBuffer {
    public static func write(_ value: [String: [FfiUri]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeFfiUri.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [FfiUri]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [FfiUri]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeFfiUri.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func ffiUriFromString(uri: String) throws -> FfiUri {
    return try FfiConverterTypeFfiUri.lift(
        rustCallWithError(FfiConverterTypeFfiError.self) {
            polywrap_native_4639_ffi_uri_from_string(
                FfiConverterString.lower(uri), $0
            )
        }
    )
}

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum PolywrapNativeLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {}
}
